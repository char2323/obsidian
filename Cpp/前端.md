### 总览

我们将从三个核心部分来详细解析：

1.  **后端：C++ API 服务器** (你的大脑和肌肉)
2.  **前端：Web 应用** (你的脸和手)
3.  **通信：API 与 JSON** (你们之间说的语言)

-----

### 1\. 后端：C++ API 服务器

你的 C++ 程序不再是一个从 `main` 函数开始，执行完就退出的控制台应用。它将转变为一个**长时间运行的服务 (Server)**。它的唯一职责是：

  * **监听网络请求**：像一个电话接线员，时刻等待前端（浏览器）打来电话。
  * **处理业务逻辑**：执行数据库的增、删、改、查，就像你之前写的功能一样。
  * **返回纯数据**：不返回任何界面元素，只返回处理结果，通常是 **JSON** 格式的数据。

#### A. 技术选型：C++ Web 框架

为了让 C++ 具备网络服务的能力，我们需要一个 HTTP 库。对于这个项目，**Crow** 是一个绝佳的选择，因为它极其轻量，只有一个头文件，无需复杂的安装。

  * **下载**：你只需要从 Crow 的 GitHub 仓库下载 `crow_all.h` 文件，并把它放在你的项目文件夹里。

#### B. 设计 RESTful API 接口

API (Application Programming Interface) 就是前后端沟通的“菜单”。我们要设计一套清晰的“菜单项”（也叫**端点 an endpoint**），让前端知道可以点什么菜。

一个好的 RESTful API 设计如下：

| 目的 | HTTP 方法 | URL 路径 | 示例 |
| :--- | :--- | :--- | :--- |
| **获取**所有电影 | `GET` | `/api/movies` | `http://localhost:18080/api/movies` |
| **获取**单部电影详情 | `GET` | `/api/movies/1` | `http://localhost:18080/api/movies/1` |
| **获取**某电影的所有场次 | `GET` | `/api/screenings?movie_id=1` | `http://localhost:18080/api/screenings?movie_id=1` |
| **创建**一个新的订单（订票） | `POST` | `/api/bookings` | 提交包含 `user_id`, `screening_id` 的数据 |
| **删除**一个订单 | `DELETE` | `/api/bookings/5` | `http://localhost:18080/api/bookings/5` |

#### C. C++ 后端代码实现 (以 Crow 为例)

现在，我们把你之前的数据库代码和一个 Crow 服务器结合起来。

```cpp
// main.cpp
#include "crow_all.h"
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/resultset.h>
#include <vector>

// 你的数据库连接函数
sql::Connection* connectToDB() {
    // ... (代码和你之前的一样)
    try {
        sql::mysql::MySQL_Driver *driver;
        sql::Connection *con;
        driver = sql::mysql::get_mysql_driver_instance();
        con = driver->connect("tcp://127.0.0.1:3306", "your_user", "your_password");
        con->setSchema("your_database_name");
        return con;
    } catch (sql::SQLException &e) {
        return nullptr;
    }
}

int main() {
    crow::SimpleApp app;

    // API端点 1: 获取所有电影列表
    // 对应路径: GET /api/movies
    CROW_ROUTE(app, "/api/movies")([](){
        sql::Connection* con = connectToToDB();
        if (!con) {
            return crow::response(500, "{\"error\": \"Database connection failed\"}");
        }

        try {
            std::unique_ptr<sql::Statement> stmt(con->createStatement());
            std::unique_ptr<sql::ResultSet> res(stmt->executeQuery("SELECT movie_id, title, genre FROM Movies"));

            // 使用 Crow 的 JSON 功能来构建一个列表
            std::vector<crow::json::wvalue> movies;
            while (res->next()) {
                crow::json::wvalue movie;
                movie["id"] = res->getInt("movie_id");
                movie["title"] = res->getString("title");
                movie["genre"] = res->getString("genre");
                movies.push_back(std::move(movie));
            }
            delete con;

            // 把 C++ vector 转换成最终的 JSON 对象
            crow::json::wvalue result;
            result["movies"] = std::move(movies);
            return crow::response(result);

        } catch (sql::SQLException &e) {
            delete con;
            return crow::response(500, "{\"error\": \"Query failed\"}");
        }
    });
    
    // API端点 2: 订票 (简化版)
    // 对应路径: POST /api/bookings
    CROW_ROUTE(app, "/api/bookings").methods(crow::HTTPMethod::Post)
    ([](const crow::request& req){
        // 1. 解析前端发来的JSON数据
        auto data = crow::json::load(req.body);
        if (!data) {
            return crow::response(400, "{\"error\": \"Invalid JSON\"}");
        }

        int userId = data["user_id"].i();
        int screeningId = data["screening_id"].i();
        
        // 2. 在这里调用你的数据库存储过程或者执行SQL语句来创建订单
        // ... (省略数据库操作代码, 比如调用 CALL BookTicket(...))
        
        // 3. 返回成功信息
        crow::json::wvalue result;
        result["message"] = "Booking successful!";
        result["user_id"] = userId;
        result["screening_id"] = screeningId;

        return crow::response(201, result); // 201 表示资源创建成功
    });


    // 启动服务器，监听 18080 端口
    app.port(18080).multithreaded().run();

    return 0;
}
```

**如何运行后端？**
编译并运行这个 C++ 程序。你会看到光标停在那里，不会退出。这说明你的服务器已经成功启动，并正在等待来自 `http://localhost:18080` 的请求。

-----

### 2\. 前端：Web 应用

前端由三个基本技术组成，运行在用户的浏览器里。

1.  **HTML (`index.html`)**: 网页的骨架。
2.  **CSS (`style.css`)**: 网页的皮肤和样式。
3.  **JavaScript (`app.js`)**: 网页的灵魂和大脑，负责与用户交互，以及和后端 API 通信。

#### A. 项目文件结构

创建一个文件夹，例如 `movie-frontend`，包含以下文件：

```
movie-frontend/
├── index.html
├── style.css
└── app.js
```

#### B. 前端代码实现

  * **`index.html`**

<!-- end list -->

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>电影订票系统</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>电影列表</h1>
        <div id="movie-list">
            </div>
    </div>
    <script src="app.js"></script>
</body>
</html>
```

  * **`style.css`** (一些简单的样式)

<!-- end list -->

```css
body { font-family: Arial, sans-serif; background-color: #f4f4f4; }
.container { max-width: 800px; margin: auto; padding: 20px; }
.movie-card { background: white; border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 5px; }
.movie-card h3 { margin-top: 0; }
```

  * **`app.js` (核心逻辑)**

<!-- end list -->

```javascript
// 当整个页面加载完成后执行
document.addEventListener('DOMContentLoaded', () => {
    fetchMovies();
});

// 定义一个函数来获取电影数据并更新页面
function fetchMovies() {
    const movieListDiv = document.getElementById('movie-list');
    movieListDiv.innerHTML = '<p>正在加载电影...</p>';

    // 使用 fetch API 向 C++ 后端发起 GET 请求
    fetch('http://localhost:18080/api/movies')
        .then(response => {
            if (!response.ok) {
                throw new Error('网络响应错误');
            }
            return response.json(); // 将响应体解析为 JSON
        })
        .then(data => {
            movieListDiv.innerHTML = ''; // 清空加载提示
            // data 就是从 C++ 后端返回的 {"movies": [...]} 对象
            data.movies.forEach(movie => {
                // 为每一部电影动态创建一个 HTML 元素 (卡片)
                const movieCard = document.createElement('div');
                movieCard.className = 'movie-card';
                movieCard.innerHTML = `
                    <h3>${movie.title}</h3>
                    <p>类型: ${movie.genre}</p>
                `;
                movieListDiv.appendChild(movieCard);
            });
        })
        .catch(error => {
            console.error('获取电影数据失败:', error);
            movieListDiv.innerHTML = '<p style="color: red;">加载电影失败！请确保后端服务已启动。</p>';
        });
}
```

-----

### 3\. 开发流程与关键问题

1.  **启动后端**：首先，编译并运行你的 C++ 程序。它会作为一个服务器在后台运行。
2.  **启动前端**：用浏览器打开 `index.html` 文件。
3.  **CORS 问题**：你很可能会在浏览器的控制台 (按 F12 打开) 看到一个关于 **CORS (Cross-Origin Resource Sharing)** 的错误。这是因为出于安全考虑，浏览器默认禁止一个域名下的网页 (`file:///...`) 去请求另一个域名下的资源 (`http://localhost:18080`)。
      * **解决方案**：在 C++ Crow 后端，添加一个“中间件”来允许所有跨域请求（仅限开发时使用）。
    <!-- end list -->
    ```cpp
    // 在 main 函数的开头添加这个
    crow::App<crow::CORSHandler> app;

    // 配置 CORS 规则
    app.get_middleware<crow::CORSHandler>()
      .global()
        .headers("Content-Type")
        .methods("POST"_method, "GET"_method)
      .prefix("/api")
        .origin("http://localhost:8000"); // 这里写你前端的来源，如果是本地文件，有时用 * 更方便

    // ... 你的 CROW_ROUTE 定义 ...
    ```
    对于最简单的本地文件测试，你可能需要一个本地 web server 来服务你的 HTML 文件，而不是直接用 `file://` 打开。Python 的 `http.server` 或 Node.js 的 `live-server` 都是很好的工具。

### 总结

这个方案的流程是：

1.  **浏览器**加载 `index.html`。
2.  `app.js` 中的 `fetch` 函数向 `http://localhost:18080/api/movies` 发送一个 `GET` 请求。
3.  正在运行的 **C++ Crow 服务器**接收到这个请求。
4.  C++ 代码执行对应的路由处理函数，连接数据库，查询电影，并将结果打包成一个 **JSON** 字符串。
5.  C++ 服务器将这个 JSON 字符串作为 HTTP 响应发送回**浏览器**。
6.  `app.js` 的 `.then(data => ...)` 部分接收到 JSON 数据，并用 JavaScript 动态地创建 HTML 元素，将电影信息显示在页面上。

通过这种方式，你的 C++ 代码专注于强大的数据处理和业务逻辑，而前端代码专注于提供美观和流畅的用户体验。这是一个非常强大且灵活的组合。
