# 哈希表核心原理

## 哈希表和 MAP （键值映射）

首先要明确：哈希表和 MAP （键值映射）是不同的。简单来说，哈希表是一种底层的数据结构实现方案，而 MAP 是一个更抽象的逻辑概念（接口/抽象数据类型）。详细对比：

### 1. 核心定义与本质

- **Map（映射）**：这是一个**抽象数据类型（ADT）**，定义了“键-值对”存储的逻辑。它只规定了你需要通过 `Key` 找到 `Value`，但并不限制底层是怎么实现的。
- **哈希表（Hash Table）**：这是一种具体的**数据结构实现方式**。它通过哈希函数将键映射到数组的下标，从而实现快速访问。

换句话说，可以认为 `HashMap` 的 `get,put,remove` 方法的复杂度都是 $O(1)$ 的，但不能说 `MAP` 接口的复杂度都是 $O(1)$。因为如果换为其他的实现类，比如底层使用二叉树结构实现的 `treemap`，这些方法的复杂度就变为 $O(\log N)$ 了。

### 2. C++ 中的具体体现

在 C++ 的 STL 中，有两类 Map，它们的底层实现正好解释了这两者的关系：

| **特性**    | **std::map (有序映射)**  | **std::unordered_map (哈希表实现)** |
| --------- | -------------------- | ------------------------------ |
| **底层实现**  | **红黑树**（平衡二叉搜索树）     | **哈希表**                        |
| **查找复杂度** | $O(\log N)$          | 平均 $O(1)$，最坏 $O(N)$            |
| **元素顺序**  | **自动排序**（按 Key 从小到大） | **无序**                         |
| **内存开销**  | 较低                   | 较高（需要预留桶空间和处理冲突）               |
### 3. 主要差异总结

#### 查找效率

- **哈希表实现 (unordered_map)**：在没有严重哈希冲突的情况下，查找几乎是瞬间完成的（常数时间复杂度）。
- **树实现 (map)**：查找速度随着数据量增加而变慢（对数时间复杂度），但性能非常稳定。

#### 顺序性

- 如果需要按顺序遍历数据（例如：按学号从小到大输出学生信息），**Map**（红黑树实现）是唯一选择。
- 如果只关心能不能快速通过 ID 找到人，不在乎遍历时的顺序，**哈希表**性能更优。

#### 对 Key 的要求

- **Map** 要求 Key 必须支持 **“小于” (`<`) 运算符**，以便构建排序树。
- **哈希表** 要求 Key 必须支持 **哈希函数** 和 **“等于” (`==`) 运算符**，以便计算位置和判断冲突。

#### 刷题时的选择建议

可以这样记：

1. **如果需要有序性**（比如题目要求输出结果必须排序），或者需要查找“大于等于某值的第一个元素”（`lower_bound`），请使用基于红黑树的 **`std::map`**。
2. **如果追求极致的查找速度**（比如在层序遍历中记录已访问的节点），请使用基于哈希表的 **`std::unordered_map`**。

## 哈希表的基本原理

哈希表可以理解为一个加强版本的数组。数组可以通过索引在 $O(1)$ 的时间复杂度内查找到对应元素，索引是一个非负整数。哈希表是类似的，可以通过 `key` 在 $O(1)$ 的时间复杂度内查找到这个 `key` 对应的 `value`。`key` 的类型可以是数字、字符串等等。

本质上，哈希表的底层实现就是一个数组（不妨称之为 `table`）。它先把这个 `key` 通过一个哈希函数（不妨称之为 `hash`）转化为数组里面的索引，然后增删改查操作和数组基本相同：

```cpp
class MyHashMap{
//伪代码逻辑
private:
	vector<void*> table;
public:
	// 增/改：时间复杂度都是O(1)
	void put(auto key,auto value){
		int index = hash(key);
		table[index] = value;
	}
	// 查，时间复杂度O(1)
	auto get(auto key){
		int index = hash(key);
		return table[index];
	}
	// 删，时间复杂度O(1)
	void remove(auto key){
		int index = hash(key);
		table[index] = nullptr;
	}
private:
	//哈希函数，把key转化为table中的合法索引
	//时间复杂度必须是O(1)才可以保证上面的操作都是O(1)的
	int hash(auto key){
		//....
	}
}
```

细节上，还要处理哈希函数的设计和哈希冲突的处理。

## 几个关键概念和原理

`key` 是唯一的，而 `value` 可以重复。

哈希函数的作用是把任意长度的输入（`key`）转化为固定长度的输出（索引）。

在上面的伪代码中，增删改查的方法中都会用到哈希函数来计算索引，如果设计的哈希函数的复杂度是 $O(N)$，那么哈希表的增删改查性能就会退化为 $O(N)$，所以*哈希函数的性能至关重要*。

此外，哈希函数还需要保证：输入相同的 `key`, 输出也要相同，这样才可以保证哈希表的而正确性。

**接下来我们自然要考虑哈希函数是如何将 key 转化为整数，并且保证索引的合法性呢？**

我们直接看 `std::unordered_map`：

### 哈希化 (Hashing)

第一步先将 key 转化为整数（哈希函数）。

在 C++ 中，这个任务由 `std::hash<Key>` 模板类完成。对于内置类型（如 `int`, `float`, `std::string`），标准库已经内置了实现。

对于整数类型，通常非常简单，甚至直接返回原值；对于字符串或者复杂类型，会使用专门的算法来尽可能均匀地分布结果，其核心逻辑是：
- 遍历对象的所有字节
- 通过位运算（左移、右移、异或）和乘法（乘以大素数）不断累加结果
- 最终输出一个 `size_t` 类型的整数

### 映射 (Mapping/Compression)

第二步：保证索引的合法性。

哈希函数返回的 `size_t` 范围是 0 到 $2^{64}-1$，而哈希表底层的数组大小是有限的（假设大小为 $N$）。为了保证索引在 $[0,N-1]$ 范围内，需要进行取模运算或者位运算。

#### 方法 A：取模运算（Modulo）

最常见的方法是：
$$index=hash \_ value(modN)$$
- **如何保证合法**：余数一定小于除数 N。
- **优化**：为了减少冲突，C++ 的许多实现会将 N 设置为**质数**。

#### 方法 B：按位与运算（Bitwise AND）

如果哈希表的大小 $N$ 恰好是 **2 的幂**（如 16, 32, 64...），可以使用更高效的位运算：
$$index=hash \_value \& (N−1)$$
- **原理**：例如 N=16（二进制 `10000`），则 N−1=15（二进制 `01111`）。任何数与其进行 `&` 运算，结果的高位都会被清零，只剩下低 4 位，范围恰好是 0−15。

### 自定义结构

如果想把自定义的 `struct` 放入 `unordered_map`，需要做两件事：

1. **特化 `std::hash`**：告诉编译器怎么把你的结构体变算成整数。
2. **重载 `operator==`**：当两个 Key 的哈希值撞车时，编译器需要用 `==` 来判断它们是真的相同还是只是倒霉撞上了。

## 哈希冲突 (Collision)

### 概念及解决方式

即便索引合法，不同的 `key` 还是可能算出来同一个索引（也就是哈希冲突）。哈希冲突时不可避免的，因为 `hash` 函数将无穷大的空间映射到了一个有限的索引空间上，必然会有不同的 `key` 映射到同一个索引上。

有两种常见的解决方式：
1. **拉链法**
2. **线性探查法**（也称作开放寻址法）
其实也就是纵向延伸（拉链法）和横向延伸（线性探查法）。

拉链法相当于是哈希表的底层数组并不直接存储 `value` 类型，而是存储一个链表，当有多个不同的 `key` 映射到同一个索引上，这些 `key->value` 对就存储在这个链表中；

线性探查法的思路是，当一个 `key` 发现算出来的 `index` 已经被别的 `key` 占用，那么就去 `index+1` 的位置看看，如果还是被占用了，那就继续往后找，直到找出一个空位。

### 扩容和负载因子

虽然拉链法和线性探查法可以解决哈希冲突，但是会导致性能下降：

- 在拉链法中，算出了 `index = hash(key)` 这个索引，但是查到的是一个链表，那么还需要遍历这个链表，才可以找到需要的 `value`, 这个时间复杂度就是 $O(K)$ 了，`K` 是链表的长度。
- 线性探查法也是类似，在算出的 `index` 位置存储的不是 `key`, 但是由于线性探查法解决哈希冲突的方式，不能确定这个 `key` 是否真的不存在，所以必须顺着这个索引往后找，一直找到一个空位置或者找到这个 `key` 位置，这个时间复杂度也是 $O(K)$，`K` 为连续探查的次数。

所以，倘若冲突频繁出现，那么 `K` 的值就会增大，使得哈希表的性能显著下降。先分析原因，然后再看解决方案：

**原因**：
1. 哈希函数设计的不好，导致 `key` 的哈希值分布不均，很多 `key` 映射到了一个索引上;
2. 哈希表已经装了太多的 `key-value` 对了，这种情况下哈希函数再好也不能避免冲突。

解决方式：
1. 第一个问题，开发语言的时候大佬们都做好了；
2. 第二个问题，为了解决装的太满，我们引出了**负载因子**的概念。

#### 负载因子

负载因子是一个哈希表装满的程度的度量。一般来说，负载因子越大，说明哈希表里面存储的 `key-value` 对越多，哈希冲突的概率就越大，哈希表的操作性能就越差。

**负载因子的计算公式也很简单，就是 `size / table.length`**。其中 `size` 是哈希表里面的 `key-value` 对的数量，`table.length` 是哈希表底层数组的容量。

你不难发现，用拉链法实现的哈希表，负载因子可以无限大，因为链表可以无限延伸；用线性探查法实现的哈希表，负载因子不会超过 1。

当哈希表内元素达到复杂因子的时候，哈希表会扩容。就是把哈希表底层 `table` 数组容量扩大，把数据搬移到新的大数组中。`size` 不变，`table. lenth` 增加，复杂因子就变小了。

### 哈希表的遍历顺序

哈希表中键的遍历顺序是无序的，**不能依赖哈希表的遍历顺序来编写程序**。因为哈希表的遍历本质上就是遍历那个底层的 table 数组：

```cpp
KVNode[] table = new KVNode[1000];

List<KeyType> keys = new ArrayList<>();

for(int i=0;i<table.length();i++){
	KVNode node = table[i];
	if(node){
		keys.add(node.key);
	}
}
```

这样是错误的。

首先由于 `hash` 函数需要把 `key` 进行映射，所以 `key` 在底层 `table` 数组中的分布是随机的，不像数组/链表结构那样有明确的元素顺序。

其次，哈希表在达到负载因子以后会进行扩容，`table. length` 会变化，且会搬移元素，在这个搬移过程中，会再次调用 `hash` 函数来重新计算 `key` 的哈希值（索引值），然后放入新的 `table` 数组中。而这个 `hash` 函数计算出来的索引值，依赖于 `table. length`, 所以哈希表扩容以后同一个 `key` 在 `table` 中的索引可能会发生变化，所以遍历结果的顺序和之前就不同了。

基于上面的分析，尽量也要**避免在 `for` 循环中增删元素**：遍历哈希表的 `key` 本质上就是在遍历哈希 `table`, 如果一边遍历一边增删元素，倘若在这个过程中触发了扩容/缩容操作，整个 `table` 数组都发生了变化，那么接下来的行为是什么样的而呢？所以这个行为一定是不建议的。

## key 一定要是不可变类型

如果 Key 在存入哈希表后发生了改变，会导致整个容器的逻辑崩溃。原因主要有以下三点：

### 1. 索引定位失效（The "Lost" Element）

哈希表寻找元素的过程是：
1. 计算 `hash(key)` 得到一个整数。
2. 通过取模等运算映射到某个“桶”（Bucket）索引。

**如果你修改了 Key：**

它的哈希值通常也会随之改变。当你再次尝试用这个修改后的 Key 去查找时，哈希表会计算出一个**全新的索引位置**。然而，原本的 Value 还躺在旧索引对应的桶里。 j 结果是：虽然对象还在内存里，但哈希表却告诉你“找不到了”。

### 2. 破坏桶内的链表逻辑

哈希冲突时，同一个桶里会有一个链表。查找时，哈希表会：
1. 先找到桶。
2. 遍历链表，用 `key == node->key` 来对比。
如果你修改了 Key 导致它本该去 5 号桶，但它还留在 3 号桶。即便哈希表遍历 3 号桶，因为 Key 的值变了，`==` 判断也会失败。

### 3. 维护开销与数据一致性

哈希表是一个**空间换时间**的结构，它通过维护“Key 与位置”的绑定关系来换取 $O(1)$ 的速度。

- 如果允许 Key 随意改变，哈希表就必须在每次 Key 改变时，重新计算哈希、重新分配桶、甚至可能触发 Rehash（扩容重排）。
- 为了性能，C++ STL 选择将这个责任交给开发者：**你可以修改 Value，但绝对不要动 Key。**

### C++ 里的防御机制

虽然 C++ 允许你自定义复杂的结构体作为 Key，但它通过一些设计细节来提示你“不要动”：

- **`std::pair` 的返回值**：当你遍历 `unordered_map` 时，得到的元素类型是 `std::pair<const Key, Value>`。注意到那个 **`const`** 了吗？
- **编译约束**：如果你尝试 `it->first = new_key;`，你的编译器会立刻报错，告诉你 `first` 是只读的。

### 实际开发中的“大忌”

如果你确实需要修改 Key，正确的做法是：

1. **删除**旧的 Key-Value 对。
2. **修改** Key 的值。
3. **重新插入**修改后的 Key-Value 对。

这样可以确保哈希表能根据新的 Key 重新计算位置，保证数据结构的完整性。

# 用拉链法实现哈希表

![[Pasted image 20260212163321.png]]

## 拉链法的简易实现

先限制我们的哈希表只支持 `key` 类型为 `int`, `value` 类型为 `int` 的情形，如果 `key` 不存在就返回 `-1`。以取模的方式实现哈希函数，也就是 `hash(key) = key % table.length`。这样也可以模拟出哈希冲突的情况：当 `table. length = 10` 的时候，`hash (1)` 和 `hash (11)` 的值都是 `1`。底层的 table 数组的大小在创建哈希表的时候确定，不考虑负载因子和动态扩容的问题。

```cpp
#include <vector>
#include <list>
#include <algorithm>

// 用拉链法解决哈希冲突的简化实现
class ExampleChainingHashMap {

    // 链表节点，存储 key-value 对儿
    // 注意这里必须存储同时存储 key 和 value
    // 因为要通过 key 找到对应的 value
    struct KVNode {
        int key;
        int value;

        // 为了简化，我这里直接用标准库的 LinkedList 链表
        // 所以这里就不添加 next 指针了
        // 你当然可以给 KVNode 添加 next 指针，自己实现链表操作
        KVNode(int key, int value) : key(key), value(value) {}
    };

    // 底层 table 数组中的每个元素是一个链表
    std::vector<std::list<KVNode>> table;

public:
    ExampleChainingHashMap(int capacity) : table(capacity) {}

    int hash(int key) {
        return key % table.size();
    }

    // 查
    int get(int key) {
        int index = hash(key);

        if (table[index].empty()) {
            // 链表为空，说明 key 不存在
            return -1;
        }

        for (const auto& node : table[index]) {
            if (node.key == key) {
                return node.value;
            }
        }

        // 链表中没有目标 key
        return -1;
    }

    // 增/改
    void put(int key, int value) {
        int index = hash(key);

        if (table[index].empty()) {
            // 链表为空，新建一个链表，插入 key-value
            table[index].push_back(KVNode(key, value));
            return;
        }

        // 链表不为空，要遍历一遍看看 key 是否已经存在
        // 如果存在，更新 value
        // 如果不存在，插入新节点
        for (auto& node : table[index]) {
            if (node.key == key) {
                // key 已经存在，更新 value
                node.value = value;
                return;
            }
        }

        // 链表中没有目标 key，添加新节点
        // 这里使用 push_back 添加到链表尾部
        // 因为 c++ std::list 的底层实现是双链表，头尾操作都是 O(1) 的
        // https://labuladong.online/algo/data-structure-basic/linkedlist-implement/
        table[index].push_back(KVNode(key, value));
    }

    // 删
    void remove(int key) {
        auto& list = table[hash(key)];
        if (list.empty()) {
            return;
        }

        // 如果 key 存在，则删除
        // 这个 remove_if 方法是 c++ std::list 的方法，可以删除满足条件的元素，时间复杂度 O(N)
        list.remove_if([key](KVNode& node) { return node.key == key; });
    }
};
```

## 完整代码实现

```cpp
#include <vector>
#include <iostream>

using namespace std;

// 1. 定义链表节点
struct Node {
    int key;
    int value;
    Node* next; // 指向下一个同桶元素的指针

    Node(int k, int v) : key(k), value(v), next(nullptr) {}
};

class ChainingHashTable {
private:
    // 数组里存的是指针，指向链表的头节点
    vector<Node*> table; 
    int capacity;
    int size;

    int hash(int key) {
        return abs(key) % capacity;
    }

public:
    ChainingHashTable(int cap) : capacity(cap), size(0) {
        // 初始化每个桶都为空 (nullptr)
        table.resize(capacity, nullptr);
    }

    // --- 析构函数：防止内存泄漏 ---
    ~ChainingHashTable() {
        for (int i = 0; i < capacity; i++) {
            Node* curr = table[i];
            while (curr != nullptr) {
                Node* toDelete = curr;
                curr = curr->next;
                delete toDelete; // 释放链表中的每一个节点
            }
        }
    }

    // --- 插入 / 更新 ---
    void put(int key, int value) {
        int index = hash(key);
        Node* curr = table[index];

        // 1. 扫描链表，看 key 是否已存在（更新逻辑）
        while (curr != nullptr) {
            if (curr->key == key) {
                curr->value = value; // 找到了，更新值
                return;
            }
            curr = curr->next;
        }

        // 2. 如果没找到，采用“头插法”插入新节点
        // (头插法是 O(1) 的，比尾插法快，而且代码简单)
        Node* newNode = new Node(key, value);
        newNode->next = table[index]; // 新节点的 next 指向旧的头
        table[index] = newNode;       // 桶的头指针指向新节点
        size++;
    }

    // --- 查找 ---
    int get(int key) {
        int index = hash(key);
        Node* curr = table[index];

        // 遍历链表查找
        while (curr != nullptr) {
            if (curr->key == key) {
                return curr->value;
            }
            curr = curr->next;
        }
        return -1; // 没找到
    }

    // --- 删除 (比线性探查简单多了！) ---
    bool remove(int key) {
        int index = hash(key);
        Node* curr = table[index];
        Node* prev = nullptr;

        while (curr != nullptr) {
            if (curr->key == key) {
                // 找到了，准备删除
                if (prev == nullptr) {
                    // 情况 A: 要删的是头节点
                    table[index] = curr->next;
                } else {
                    // 情况 B: 要删的是中间或尾部节点
                    prev->next = curr->next;
                }
                
                delete curr; // 真正释放内存
                size--;
                return true;
            }
            // 继续往下找
            prev = curr;
            curr = curr->next;
        }
        return false; // 没找到
    }

    void print() {
        for (int i = 0; i < capacity; i++) {
            cout << "Bucket [" << i << "]: ";
            Node* curr = table[i];
            while (curr != nullptr) {
                cout << "(" << curr->key << ":" << curr->value << ") -> ";
                curr = curr->next;
            }
            cout << "NULL" << endl;
        }
    }
};

int main() {
    ChainingHashTable ht(5); //只有5个桶，很容易冲突

    ht.put(1, 100);  // Hash: 1
    ht.put(6, 200);  // Hash: 1 (冲突！挂在 1 后面)
    ht.put(11, 300); // Hash: 1 (再次冲突！挂在 6 前面/后面)
    ht.put(2, 50);   // Hash: 2

    cout << "--- 插入后 ---" << endl;
    ht.print();

    cout << "\n查找 6: " << ht.get(6) << endl;

    cout << "\n删除 6 (链表中间的元素)..." << endl;
    ht.remove(6);
    ht.print();

    return 0;
}
```

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <stdexcept>

template <typename K, typename V>
class ChainingHashMap {
private:
    struct Node {
        K key;
        V value;
        Node(K k, V v) : key(k), value(v) {}
    };

    std::vector<std::list<Node>> table;
    int size;
    int capacity;
    const double loadFactorThreshold = 0.75;

    int getHashIndex(const K& key) const {
        // 使用 std::hash<K>，支持你刷题常用的 int, string 等类型
        return std::hash<K>{}(key) % capacity;
    }

    void rehash(int newCapacity) {
        std::vector<std::list<Node>> oldTable = std::move(table);
        capacity = newCapacity;
        table.assign(capacity, std::list<Node>());
        size = 0;

        for (auto& bucket : oldTable) {
            for (auto& node : bucket) {
                put(node.key, node.value);
            }
        }
    }

public:
    ChainingHashMap(int cap = 16) : capacity(cap), size(0) {
        table.resize(capacity);
    }

    // 【增/改】
    void put(const K& key, const V& value) {
        if ((double)size / capacity >= loadFactorThreshold) {
            rehash(capacity * 2);
        }

        int index = getHashIndex(key);
        for (auto& node : table[index]) {
            if (node.key == key) {
                node.value = value; // 存在则【改】
                return;
            }
        }
        table[index].emplace_back(key, value); // 不存在则【增】
        size++;
    }

    // 【查】获取值
    V get(const K& key) const {
        int index = getHashIndex(key);
        for (const auto& node : table[index]) {
            if (node.key == key) return node.value;
        }
        throw std::runtime_error("Key not found"); // 或者返回 std::optional
    }

    // 【查】判断是否存在
    bool contains(const K& key) const {
        int index = getHashIndex(key);
        for (const auto& node : table[index]) {
            if (node.key == key) return true;
        }
        return false;
    }

    // 【删】物理删除，无需墓碑
    bool remove(const K& key) {
        int index = getHashIndex(key);
        auto& bucket = table[index];
        for (auto it = bucket.begin(); it != bucket.end(); ++it) {
            if (it->key == key) {
                bucket.erase(it);
                size--;
                return true;
            }
        }
        return false;
    }

    // 【遍历】获取所有键
    std::vector<K> keys() const {
        std::vector<K> allKeys;
        allKeys.reserve(size);
        for (const auto& bucket : table) {
            for (const auto& node : bucket) {
                allKeys.push_back(node.key);
            }
        }
        return allKeys;
    }

    int getSize() const { return size; }
};

int main() {
    // 1. 初始化哈希表（初始容量设小一点，方便观察扩容）
    ChainingHashMap<std::string, int> ageMap(4);

    std::cout << "--- 开始功能测试 ---" << std::endl;

    // 2. 【增/改】测试
    ageMap.put("Alice", 25);
    ageMap.put("Bob", 30);
    ageMap.put("Charlie", 22);
    ageMap.put("David", 28); // 此时 size=4, capacity=4, 达到 0.75 阈值，会触发 rehash
    
    std::cout << "插入 4 个元素后，当前大小: " << ageMap.getSize() << std::endl;
    
    // 3. 【查】测试
    std::cout << "查找 Alice 的年龄: " << ageMap.get("Alice") << " (期待: 25)" << std::endl;
    std::cout << "是否存在 Eve: " << (ageMap.contains("Eve") ? "是" : "否") << " (期待: 否)" << std::endl;

    // 4. 【改】更新现有键
    ageMap.put("Alice", 26);
    std::cout << "更新后 Alice 的年龄: " << ageMap.get("Alice") << " (期待: 26)" << std::endl;

    // 5. 【删】测试
    bool removed = ageMap.remove("Bob");
    std::cout << "删除 Bob " << (removed ? "成功" : "失败") << "，当前大小: " << ageMap.getSize() << std::endl;

    // 6. 【遍历】获取所有键
    std::vector<std::string> allKeys = ageMap.keys();
    std::cout << "当前表内所有的 Key: ";
    for (const auto& k : allKeys) {
        std::cout << k << " ";
    }
    std::cout << std::endl;

    // 7. 异常测试
    try {
        ageMap.get("Nobody");
    } catch (const std::runtime_error& e) {
        std::cout << "捕获到预期的异常: " << e.what() << std::endl;
    }

    std::cout << "\n--- 所有测试通过 ---" << std::endl;
    return 0;
}
```

# 线性探查法

![[Pasted image 20260212164510.png]]

线性探查法（Linear Probing）是哈希表解决冲突（Open Addressing）中最直观、最经典的方法。

虽然它的思路简单（“这个坑被占了？那我去隔壁看看”），但在实际工程实现中，它有两个著名的**难点**：**“堆积效应（Clustering）”** 和 **“删除陷阱（Deletion Problem）”**。

## 难点

### 核心逻辑：像停车场一样

想象一个环形停车场：

1. **停车（Insert）**：你拿着一张票（Key），算出来你应该停在 5 号位。
    - 如果 5 号位是空的，停进去。
    - 如果 5 号位被占了，你只能顺着去 6 号、7 号... 直到找到第一个空位。
    - _注意：如果到了末尾，要回到开头（0 号）继续找。_
2. **找车（Search）**：你要找 Key 为 X 的车。
    - 算出 X 应该在 5 号。
    - 去 5 号看，如果 Key 不对，就去 6 号看...
    - **停止条件**：找到了 Key，或者遇到了**空位**（说明车根本没停进来，否则它应该停在这个空位里）。   

### 难点 1：删除陷阱 (The Deletion Problem)

这是线性探查法最容易写出 Bug 的地方。

**场景**：
1. 插入 A (Hash 5) -> 停在 5 号。
2. 插入 B (Hash 5) -> 5 号有人，停在 6 号。
3. **删除 A**：把 5 号置为 `nullptr`（空位）。
4. **查找 B**：算出 B 应该在 5 号 -> 5 号是空位 -> **报错“B 不存在”**。

**原因**：线性探查的查找依赖于“连续性”。一旦你把中间挖了一个空洞（`nullptr`），后面的元素就“断链”了。

**解决方案：墓碑机制 (Tombstone / Lazy Deletion)**

我们不能真删，而是放一个“墓碑”标记（比如 `DELETED` 状态）。

- **查找时**：遇到“墓碑”不能停，继续往后找。
- **插入时**：遇到“墓碑”可以视为“空位”，把新数据覆盖上去。

### 难点 2：堆积效应 (Clustering)

这是性能杀手。

如果你运气不好，哈希冲突导致数据连成了一长串（比如下标 100 到 200 全满了），那么下一个插入到 100 的元素，必须跑 100 步才能找到空位。

- **后果**：哈希表本来是 $O(1)$ 的，现在退化成了 $O(N)$。
- **对策**：必须保证**负载因子（Load Factor）较低（通常 < 0.5）。一旦元素超过容量的一半，就必须扩容（Rehash）**，把所有数据重新撒一遍。

## 完整代码实现

为了处理“墓碑”，我们不再使用简单的 `KVNode*` 数组，而是定义一个带有**状态枚举**的结构体。

这是最稳健的写法：

```cpp
#include <vector>
#include <iostream>
#include <string>

using namespace std;

// 1. 定义节点状态：空、占用、已删除（墓碑）
enum State { EMPTY, OCCUPIED, DELETED };

struct HashNode {
    int key;
    int value;
    State state; // 关键：用状态来管理生命周期

    HashNode() : key(0), value(0), state(EMPTY) {}
};

class LinearProbingHashTable {
private:
    vector<HashNode> table;
    int capacity;
    int size; // 当前存活的元素数量

    // 简单的哈希函数
    int hash(int key) {
        return key % capacity; // 实际中 key 应取绝对值
    }

public:
    LinearProbingHashTable(int cap) : capacity(cap), size(0) {
        // 初始化表格，全为 EMPTY
        table.resize(capacity);
    }

    // --- 插入 / 更新 ---
    bool put(int key, int value) {
        if (size >= capacity / 2) {
            cout << "警告：负载过高，建议扩容！" << endl;
            // 实际工程中这里需要调用 resize()
        }

        int index = hash(key);
        int start_index = index;
        int first_deleted_index = -1; // 记录遇到的第一个墓碑位置

        while (table[index].state != EMPTY) {
            // 如果找到了已存在的 key，直接更新
            if (table[index].state == OCCUPIED && table[index].key == key) {
                table[index].value = value;
                return true; 
            }

            // 如果遇到了墓碑，记录下来（作为备选插入点）
            if (table[index].state == DELETED && first_deleted_index == -1) {
                first_deleted_index = index;
            }

            // 线性探查：步长为 1
            index = (index + 1) % capacity;

            // 如果绕了一圈回到原点（表满了且没找到 key），由于我们限制了负载因子，这种情况极少发生
            if (index == start_index) break;
        }

        // --- 核心插入逻辑 ---
        // 如果之前遇到了墓碑，我们优先复用墓碑的位置（废物利用）
        // 否则，使用当前找到的 EMPTY 位置
        int insert_idx = (first_deleted_index != -1) ? first_deleted_index : index;

        // 只有当该位置不是 OCCUPIED 时才算新插入
        if (table[insert_idx].state != OCCUPIED) {
            size++;
        }
        
        table[insert_idx].key = key;
        table[insert_idx].value = value;
        table[insert_idx].state = OCCUPIED;
        return true;
    }

    // --- 查找 ---
    int get(int key) {
        int index = hash(key);
        int start_index = index;

        // 注意：遇到 EMPTY 才能停！遇到 DELETED 必须继续找！
        while (table[index].state != EMPTY) {
            if (table[index].state == OCCUPIED && table[index].key == key) {
                return table[index].value;
            }

            index = (index + 1) % capacity;
            if (index == start_index) break;
        }
        return -1; // 没找到
    }

    // --- 删除 (重点：墓碑法) ---
    bool remove(int key) {
        int index = hash(key);
        int start_index = index;

        while (table[index].state != EMPTY) {
            if (table[index].state == OCCUPIED && table[index].key == key) {
                // ！！！关键点！！！
                // 不使用 delete，而是标记为 DELETED
                table[index].state = DELETED;
                size--;
                return true;
            }

            index = (index + 1) % capacity;
            if (index == start_index) break;
        }
        return false;
    }

    void print() {
        for (int i = 0; i < capacity; i++) {
            if (table[i].state == OCCUPIED) 
                cout << "[" << i << "]: " << table[i].key << "(" << table[i].value << ") ";
            else if (table[i].state == DELETED)
                cout << "[" << i << "]: TOMB ";
            else 
                cout << "[" << i << "]: NULL ";
        }
        cout << endl;
    }
};

int main() {
    LinearProbingHashTable ht(10);

    // 模拟冲突
    ht.put(1, 100); // hash(1) -> 1
    ht.put(11, 200); // hash(11) -> 1, 冲突 -> 放到 2
    ht.put(21, 300); // hash(21) -> 1, 冲突 -> 2 冲突 -> 放到 3

    cout << "插入后：" << endl;
    ht.print();

    cout << "删除 11 (中间那个)..." << endl;
    ht.remove(11); // 2 号位变成墓碑
    ht.print();

    cout << "查找 21 (应该跳过墓碑找到): " << ht.get(21) << endl;

    cout << "插入 31 (应该复用墓碑 2 号位)..." << endl;
    ht.put(31, 400); 
    ht.print();

    return 0;
}
```

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

template <typename K, typename V>
class LinearProbingHashMap {
private:
    enum State { EMPTY, OCCUPIED, DELETED };
    struct Entry {
        K key;
        V value;
        State state = EMPTY;
    };

    std::vector<Entry> table;
    int size; // 仅统计 OCCUPIED
    int capacity;
    const double loadFactorThreshold = 0.5;

    int getHashIndex(const K& key) const {
        return std::hash<K>{}(key) % capacity;
    }

    void rehash(int newCapacity) {
        std::vector<Entry> oldTable = std::move(table);
        capacity = newCapacity;
        table.assign(capacity, Entry());
        size = 0;
        for (const auto& entry : oldTable) {
            if (entry.state == OCCUPIED) put(entry.key, entry.value);
        }
    }

public:
    LinearProbingHashMap(int cap = 16) : capacity(cap), size(0) {
        table.resize(capacity);
    }

    // 【增/改】
    void put(const K& key, const V& value) {
        if ((double)size / capacity >= loadFactorThreshold) rehash(capacity * 2);

        int index = getHashIndex(key);
        int firstDeleted = -1;

        while (table[index].state != EMPTY) {
            if (table[index].state == OCCUPIED && table[index].key == key) {
                table[index].value = value; // 【改】
                return;
            }
            if (table[index].state == DELETED && firstDeleted == -1) firstDeleted = index;
            index = (index + 1) % capacity;
        }

        int targetIdx = (firstDeleted != -1) ? firstDeleted : index;
        table[targetIdx] = {key, value, OCCUPIED}; // 【增】
        size++;
    }

    // 【查】
    V get(const K& key) const {
        int index = getHashIndex(key);
        int startIdx = index;
        while (table[index].state != EMPTY) {
            if (table[index].state == OCCUPIED && table[index].key == key) return table[index].value;
            index = (index + 1) % capacity;
            if (index == startIdx) break; 
        }
        throw std::runtime_error("Key not found");
    }

    // 【删】墓碑式删除
    bool remove(const K& key) {
        int index = getHashIndex(key);
        int startIdx = index;
        while (table[index].state != EMPTY) {
            if (table[index].state == OCCUPIED && table[index].key == key) {
                table[index].state = DELETED; // 标记为墓碑
                size--;
                return true;
            }
            index = (index + 1) % capacity;
            if (index == startIdx) break;
        }
        return false;
    }

    // 【遍历】
    std::vector<K> keys() const {
        std::vector<K> allKeys;
        for (const auto& entry : table) {
            if (entry.state == OCCUPIED) allKeys.push_back(entry.key);
        }
        return allKeys;
    }
};

int main() {
    // 1. 初始化哈希表（初始容量设小一点，方便观察扩容）
    ChainingHashMap<std::string, int> ageMap(4);

    std::cout << "--- 开始功能测试 ---" << std::endl;

    // 2. 【增/改】测试
    ageMap.put("Alice", 25);
    ageMap.put("Bob", 30);
    ageMap.put("Charlie", 22);
    ageMap.put("David", 28); // 此时 size=4, capacity=4, 达到 0.75 阈值，会触发 rehash
    
    std::cout << "插入 4 个元素后，当前大小: " << ageMap.getSize() << std::endl;
    
    // 3. 【查】测试
    std::cout << "查找 Alice 的年龄: " << ageMap.get("Alice") << " (期待: 25)" << std::endl;
    std::cout << "是否存在 Eve: " << (ageMap.contains("Eve") ? "是" : "否") << " (期待: 否)" << std::endl;

    // 4. 【改】更新现有键
    ageMap.put("Alice", 26);
    std::cout << "更新后 Alice 的年龄: " << ageMap.get("Alice") << " (期待: 26)" << std::endl;

    // 5. 【删】测试
    bool removed = ageMap.remove("Bob");
    std::cout << "删除 Bob " << (removed ? "成功" : "失败") << "，当前大小: " << ageMap.getSize() << std::endl;

    // 6. 【遍历】获取所有键
    std::vector<std::string> allKeys = ageMap.keys();
    std::cout << "当前表内所有的 Key: ";
    for (const auto& k : allKeys) {
        std::cout << k << " ";
    }
    std::cout << std::endl;

    // 7. 异常测试
    try {
        ageMap.get("Nobody");
    } catch (const std::runtime_error& e) {
        std::cout << "捕获到预期的异常: " << e.what() << std::endl;
    }

    std::cout << "\n--- 所有测试通过 ---" << std::endl;
    return 0;
}
```

---

## 注意点

1. **不推荐用 `delete`？**
    - 因为你的 `table` 是指针数组。一旦 `delete table[index]`，这个位置就变回 `nullptr` 了。
    - 这就犯了“断链”的忌讳。后续的查找走到这里看到 `nullptr` 就会以为“后面没有数据了”，从而停止查找，导致后面的数据丢失。
2. **线性探查 vs 链地址法 (拉链法)**
    - **线性探查 (Open Addressing)**：
        - 优点：内存紧凑，CPU 缓存极度友好（数组连续访问），不用频繁 `new` 节点。
        - 缺点：对负载因子敏感，删除麻烦（需要墓碑），容易发生堆积。
    - **链地址法 (Separate Chaining)**：
        - 优点：简单，删除容易，对负载因子不敏感（桶里链表长点也没事）。
        - 缺点：指针多，内存分散，缓存不友好。


在高性能场景（如 Python 的 `dict` 实现，或者 C++ 的某些高性能库 `flat_map`），**线性探查**往往因为缓存命中率高而胜出，但前提是必须处理好**扩容**和**墓碑**。

# 对比

| **特性**    | **线性探查 (Linear Probing)**              | **拉链法 (Separate Chaining)**              |
| --------- | -------------------------------------- | ---------------------------------------- |
| **内存结构**  | **数组** (连续内存)                          | **数组 + 链表** (分散内存)                       |
| **缓存友好度** | **极高** (CPU 预取效果好)                     | **低** (跳转指针会导致 Cache Miss)               |
| **删除操作**  | **困难** (必须用墓碑标记，否则断链)                  | **简单** (常规链表节点删除)                        |
| **空间利用率** | 当 Load Factor > 0.5 时性能急剧下降            | 可以容忍 Load Factor > 1 (只要内存够)             |
| **扩容频率**  | 频繁 (为了保持低负载)                           | 较低 (链表长点也能忍)                             |
| **极端情况**  | 容易发生堆积 (Primary Clustering)            | 某些桶特别长，但不会影响其他桶                          |
| **典型应用**  | Python `dict`, C++ 高性能库 (如 `flat_map`) | C++ `std::unordered_map`, Java `HashMap` |

# 哈希集合

> 哈希表的键，其实就是哈希集合
## 哈希集合原理

哈希集合的重要使用场景是**去重**，因为它的特性是：不会出现重复的元素，可以在 $(1)$ 时间增删元素，可以在 $O(1)$ 时间判断一个元素是否存在。

主要的 API：

```cpp
class HashSet {
public:
    // 增，向哈希集合中添加一个元素，复杂度 O(1)
    // 如果元素已存在，则什么都不会发生
    void add(int key);

    // 删，从哈希集合中移除一个元素，复杂度 O(1)
    // 如果元素不存在，则什么都不会发生
    void remove(int key);

    // 查，判断元素是否存在，复杂度 O(1)
    bool contains(int key);
};
```

正如前面说的，哈希集合就是哈希表的键，所以这些 api 可以直接利用哈希表来做：

你往哈希表里插入一个键值对 `put(key, value)`，时间复杂度是 $O(1)$；你往哈希表里删除一个键值对 `remove(key)`，时间复杂度是 $O(1)$；判断一个键是否存在哈希表中，就是判断 `get(key)` 是否得到空指针 `null`，所以时间复杂度也是 $O(1)$。

**综上，这几个哈希集合的 API 可以直接复用哈希表的 API 来实现。操作哈希集合，其实就是操作哈希表的键**。

既然我们只用到了哈希表里的键，那么哈希表里面的值呢，如何处理？答案是不处理，直接忽略掉就行了，我们可以用一个占位符来填充值，直接看代码：

```cpp
#include <unordered_map>

template<typename K>
class MyHashSet {
private:
    // 底层 unordered_map，用于存储集合元素
    std::unordered_map<K, bool> map;

public:
    void add(const K& key) {
        // 向哈希表添加一个键值对，值用 true 作为占位符
        map[key] = true;
    }

    void remove(const K& key) {
        // 从哈希表中移除键 key
        map.erase(key);
    }

    bool contains(const K& key) {
        // 判断哈希表中是否包含键 key
        return map.find(key) != map.end();
    }

    int size() {
        return map.size();
    }
};
```

## 注意点

因为哈希集合的元素就是哈希表里面的键，所以**哈希集合和哈希表具有相同的限制**，比如不能依赖哈希集合的元素遍历顺序、哈希集合中的元素应该是不可变的等等。
