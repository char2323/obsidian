# [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

用两个栈来实现即可。

```cpp
#include <stack>

class MyQueue {
public:
    std::stack<int> stIn;  // 输入栈
    std::stack<int> stOut; // 输出栈

    MyQueue() {}

    void push(int x) {
        stIn.push(x);
    }

    int pop() {
        // 只有当输出栈为空时，才从输入栈导入数据
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    int peek() {
        // peek 复用 pop 的逻辑，但不真正弹出
        int res = this->pop(); 
        stOut.push(res); // 拿出来看完再塞回去
        return res;
    }

    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```

# [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

**逻辑**：

- 每当 `push` 一个新元素，我们看当前队列里有多少个元素。
- 把除了新加入的那个元素之外的所有人，全部重新排队（弹出再推入）。
- 这样，最后进入的那个数就变成了队列的头部。

```cpp
#include <queue>

class MyStack {
public:
    std::queue<int> que;

    MyStack() {}

    // 入栈直接 push
    void push(int x) {
        que.push(x);
    }

    // 出栈操作：核心逻辑
    int pop() {
        int size = que.size();
        size--; // 我们要留下最后一个，所以移动 size - 1 个
        
        while (size--) {
            // 把队头拿出来，重新塞到队尾
            que.push(que.front());
            que.pop();
        }
        
        // 此时队头就是我们要弹出的那个“栈顶元素”
        int result = que.front();
        que.pop();
        return result;
    }

    // 获取栈顶元素
    int top() {
        // 直接返回队列的 back（队尾）即可，因为队尾就是最后进入的元素
        return que.back();
    }

    bool empty() {
        return que.empty();
    }
};
```

# [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

这是栈**最经典**的应用场景：**匹配**。

### 1. 核心思想

- 遇到左括号，把对应的“期待的右括号”压入栈。
- 遇到右括号，看它和栈顶是否一致。

**三种不匹配情况：**

1. **左多右少**：字符串走完了，栈不为空。
2. **左右不匹配**：遇到的右括号和栈顶想要的不一样。
3. **右多左少**：还没走完，栈就空了。

```cpp
bool isValid(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == '(') st.push(')');
        else if (c == '{') st.push('}');
        else if (c == '[') st.push(']');
        // 匹配失败的情况
        else if (st.empty() || st.top() != c) return false;
        else st.pop();
    }
    return st.empty();
}
```

```cpp
class Solution {
public:
  bool isValid(string s) {
    stack<char> left;

    for (char c : s) {
      if (c == '(' || c == '{' || c == '[') {
        left.push(c);
      } else {
        if (!left.empty() && leftOf(c) == left.top()) {
          left.pop();
        } else {
          return false;
        }
      }
    }
    return left.empty();
  }

private:
  char leftOf(char c) {
    if (c == ')')
      return '(';
    if (c == '}')
      return '{';
    return '[';
  }
};
```

# [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

这题本质上也是**匹配**，只不过匹配的是“相同的字母”。

- 遍历字符串，把字符入栈。
- 如果当前字符和栈顶字符一样，说明它们是“相邻重复项”，直接把栈顶弹出，当前字符也不入栈。
- 最后栈里剩下来的就是消除后的结果。

**可以用字符串来模拟栈**：

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res = ""; // 用字符串模拟栈
        
        for (char c : s) {
            // 如果栈不为空，且当前字符 c 和栈顶字符相等
            if (!res.empty() && c == res.back()) {
                res.pop_back(); // 弹出栈顶，相当于消除了相邻的重复项
            } else {
                res.push_back(c); // 否则，将字符入栈
            }
        }
        
        return res;
    }
};
```

当使用栈的时候要注意几点：

- **返回值问题**：在 C++ 中，`pop()` 函数的返回值是 `void`。如果你想获取被弹出的元素，必须先调用 `top()` (栈) 或 `front()` (队列)，然后再调用 `pop()`。
    - ❌ `char c = ans.pop();`
    - ✅ `char c = ans.top(); ans.pop();`
- **判空**：在调用 `top()`、`front()` 或 `pop()` 之前，**一定要先判断 `!empty()`**，否则在空容器上操作会引发段错误（Segment Fault）。
- **String 模拟栈**： 由于 `std::string` 提供了 `push_back()`、`pop_back()` 和 `back()`，它在功能上完全覆盖了 `stack<char>` 的需求，且最后不需要翻转。

```cpp
string removeDuplicates(string s) {
  stack<char> ans;

  for (char c : s) {
    if (!ans.empty() && c == ans.top()) {
      ans.pop();
    } else {
      ans.push(c);
    }
  }
  string result = "";
  while (!ans.empty()) {
    result += ans.top();
    ans.pop();
  }
  reverse(result.begin(), result.end());
  return result;
}
```


# 常用 API

## **std::stack (栈 - 先进后出)**

需包含头文件：`#include <stack>`

|**API**|**功能**|**说明**|
|---|---|---|
|`st.push(val)`|入栈|在栈顶添加元素|
|`st.pop()`|出栈|移除栈顶元素（**无返回值**）|
|`st.top()`|访问栈顶|获取栈顶元素的值|
|`st.empty()`|判空|返回 bool，为空则为 true|
|`st.size()`|大小|返回栈内元素个数|

## **std::queue (队列 - 先进先出)**

需包含头文件：`#include <queue>`

|**API**|**功能**|**说明**|
|---|---|---|
|`que.push(val)`|入队|在队尾添加元素|
|`que.pop()`|出队|移除队头元素（**无返回值**）|
|`que.front()`|访问队头|获取最先进入的元素|
|`que.back()`|访问队尾|获取最后进入的元素|
|`que.empty()`|判空|返回 bool|
|`que.size()`|大小|返回队列长度|

---
## `std::string`
### 1. 模拟“栈”操作的 API

当你把 `string` 当成栈（FILO）使用时，最核心的是这三个：

|**API**|**对应栈操作**|**功能说明**|
|---|---|---|
|**`s.push_back(c)`**|`st.push(c)`|在字符串末尾添加字符|
|**`s.pop_back()`**|`st.pop()`|弹出字符串最后一个字符（注意：字符串不能为空）|
|**`s.back()`**|`st.top()`|获取最后一个字符（栈顶）的值|

---

### 2. 访问与搜索（像数组一样）

`string` 最强的地方在于它提供了丰富的搜索功能：

- **`s[i]` 或 `s.at(i)`**：像数组一样通过下标访问。
- **`s.front()`**：访问第一个字符。
- **`s.find("target")`**：查找子串或字符。如果找不到，会返回一个特别大的常数 `string::npos`。

> **小技巧**：在判断是否找到时，通常写 `if (s.find('a') != string::npos)`。

---

### 3. 修改与删除（高级操作）

处理字符串题目（如“替换数字”、“反转单词”）时，这些是救命稻草：

- **`s.resize(new_size)`**：强制改变字符串长度。常用于“先统计扩容，再双指针填充”。
- **`s.append(str)`** 或 **`s += str`**：直接在后面拼接字符串。
- **`s.insert(pos, str)`**：在指定位置插入。
- **`s.erase(pos, len)`**：从 `pos` 开始删除 `len` 个字符。
- **`s.substr(pos, len)`**：截取子串。注意：第二个参数是**长度**，不是结束下标。

---

### 4. 配合 `<algorithm>` 使用的全局函数

这些不是 `string` 的成员函数，但处理 `string` 时几乎必用：

- **`reverse(s.begin(), s.end())`**：原地翻转整个字符串。
- **`sort(s.begin(), s.end())`**：把字符串按字典序排序（如处理异位词题目）。

---

### 5. 易错点预警

1. **`size()` 的类型**：`s.size()` 返回的是 `size_t`（无符号整数）。
    - ❌ 不要写 `for (int i = 0; i <= s.size() - 1; i++)`，如果 `s` 为空，`0 - 1` 会溢出成巨大的正数。
    - ✅ 推荐写 `for (int i = 0; i < s.size(); i++)`。
2. **单引号 vs 双引号**：
    - `'a'` 是字符（`char`）。
    - `"a"` 是字符串（`const char*`）。
    - `push_back` 只能接字符，`append` 或 `+=` 可以接字符串。
3. **`pop_back()` 前置检查**：
    - 调用 `pop_back()` 或 `back()` 之前，一定要确认 `!s.empty()`，否则在 Arch 上运行会报 **Segmentation Fault**。

---
