# [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

按顺序遍历逆波兰表达式中的字符，如果是数字，则放入栈；如果是运算符，则将栈顶的两个元素拿出来进行运算，再将结果放入栈。对于减法和除法，运算顺序别搞反了，栈顶第二个数是被除（减）数。

所以这题很简单，直接按照运算规则借助栈计算表达式结果即可。

```cpp
#include <vector>
#include <string>
#include <stack>

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        std::stack<int> stk;
        for (const std::string& token : tokens) {
            if (token == "+" || token == "-" || token == "*" || token == "/") {
                // 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈
                int a = stk.top(); stk.pop();
                int b = stk.top(); stk.pop();
                if (token == "+") stk.push(b + a);
                else if (token == "*") stk.push(b * a);
                else if (token == "-") {
                    // 对于减法和除法，顺序别搞反了，第二个数是被除（减）数
                    stk.push(b - a);
                }
                else if (token == "/") stk.push(b / a);
            } else {
                // 是个数字，直接入栈即可
                stk.push(std::stoi(token));
            }
        }
        // 最后栈中剩下一个数字，即是计算结果
        return stk.top();
    }
};
```

# [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

传说中的**单调队列**

```cpp
class MyQueue { // 单调队列逻辑
public:
  deque<int> que;

  // 每次弹出时，比较当前要弹出的数值是否等于队列出口的数值
  void pop(int value) {
    if (!que.empty() && value == que.front()) {
    //这里比较一次队列出口值是因为在push的时候可能会把前面的挤出去
      que.pop_front();
    }
  }

  // 重点：如果推进来的数比尾部大，就循环弹出尾部，直到满足单调递减
  void push(int value) {
    while (!que.empty() && value > que.back()) {
      que.pop_back();
    }
    que.push_back(value);
  }

  // 队头永远是最大值
  int front() { return que.front(); }
};
```

当我们写好单调队列以后，就当作普通的窗口来写即可。这里的窗口就是我们的单调队列 `que`。

```cpp
class Solution {
public:
  vector<int> maxSlidingWindow(vector<int> &nums, int k) {
    MyQueue que;
    vector<int> result;

    // 1. 先将前 k 个元素放入队列
    for (int i = 0; i < k; i++) {
      que.push(nums[i]);
    }
    result.push_back(que.front());

    // 2. 窗口开始滑动
    for (int i = k; i < nums.size(); i++) {
      // 移除窗口最左边的元素
      que.pop(nums[i - k]);
      // 加入窗口最右边的元素
      que.push(nums[i]);
      // 记录当前窗口最大值
      result.push_back(que.front());
    }
    return result;
  }
};
```

合并到一个函数可以这样：

```cpp
class Solution {
public:
  vector<int> maxSlidingWindow(vector<int> &nums, int k) {
    deque<int> dq; // 存储的是下标，这样既能取值也能判断是否过期
    vector<int> result;

    for (int i = 0; i < nums.size(); i++) {
      // 1. 入队：保持单调递减
      // 如果新来的数比队尾的大，队尾的就永远没机会了，踢掉
      while (!dq.empty() && nums[i] >= nums[dq.back()]) {
        dq.pop_back();
      }
      dq.push_back(i); // 存入下标

      // 2. 出队：判断队头是否已经移出窗口
      // i - k 是当前窗口左边界的前一个位置
      if (dq.front() <= i - k) {
        dq.pop_front();
      }

      // 3. 记录答案：当窗口形成（i >= k-1）时开始记录
      if (i >= k - 1) {
        result.push_back(nums[dq.front()]);
      }
    }
    return result;
  }
};
```

# [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

首先，用一个 `valToFreq` 哈希表把每个元素出现的频率计算出来。

然后，这道题就变成了 [215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)，只不过第 215 题要求求数组中元素值 `e` 排在第 `k` 大的那个元素，这道题要求求数组中元素值 `valToFreq[e]` 排在前 `k` 个的元素。

可以多用用 lambda 表达式来写。

```cpp
// 用优先级队列解决这道题
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // nums 中的元素 -> 该元素出现的频率
        unordered_map<int, int> valToFreq;
        for (int v : nums) {
            valToFreq[v]++;
        }

        auto cmp = [](pair<int, int>& entry1, pair<int, int>& entry2) {
            // 队列按照键值对中的值（元素出现频率）从小到大排序
            return entry1.second > entry2.second;
        };
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);

        for (auto& entry : valToFreq) {
            pq.push(entry);
            if (pq.size() > k) {
                // 弹出最小元素，维护队列内是 k 个频率最大的元素
                pq.pop();
            }
        }

        vector<int> res(k);
        for (int i = k - 1; i >= 0; i--) {
            // res 数组中存储前 k 个最大元素
            res[i] = pq.top().first;
            pq.pop();
        }

        return res;
    }
};
```

```cpp
#include <vector>
#include <unordered_map>
#include <queue>

using namespace std;

class Solution {
public:
    // 定义比较规则：频率小的优先级高（为了构建小顶堆）
    struct MyComparison {
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1. 统计频率
        unordered_map<int, int> map;
        for (int num : nums) map[num]++;

        // 2. 对频率进行排序：定义一个小顶堆
        priority_queue<pair<int, int>, vector<pair<int, int>>, MyComparison> pri_que;

        // 用固定大小为 k 的小顶堆扫描 map
        for (auto it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) { // 如果堆的大小超过了 k，弹出最小的
                pri_que.pop();
            }
        }

        // 3. 找出前 k 个高频元素
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;
    }
};
```
