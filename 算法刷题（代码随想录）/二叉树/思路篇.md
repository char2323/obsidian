> [!note]
> Contents二叉树解题的思维模式分两类：
> 
> **1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。
> 
> **2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。
> 
> 无论使用哪种思维模式，你都需要思考：
> 
> **如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

# [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

> [!question]
> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
> 
> **示例 1：**
> 
> ![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)
> 
> **输入：** root = [4,2,7,1,3,6,9]
> **输出：** [4,7,2,9,6,3,1]
> 
> **示例 2：**
> 
> ![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)
> 
> **输入：** root = [2,1,3]
> **输出：** [2,3,1]
> 
> **示例 3：**
> 
> **输入：** root = []
> **输出：** []
> 
> **提示：**
> 
> - 树中节点数目范围在 `[0, 100]` 内
> - `-100 <= Node.val <= 100`

> 核心的想法就是：将二叉树上每一个节点的左右子节点进行交换，最终的结果就是完全翻转二叉树

所以现在来想想二叉树的解题纲领：

## 1. 能不能用“遍历”的思维模式来解题？

当然可以，我可以写一个 traverse 函数遍历每个节点，让每个节点的而左右子节点颠倒过来即可。

单独抽出一个节点，需要让它做什么呢？让它把自己的左右子节点交换一下即可。

需要在什么时候做呢？没有严格要求，似乎前中后都可以。

我们可以写出如下代码：

```cpp
class Solution{
public:
	TreeNode* invertTree(TreeNode* root){
		if(root!=nullptr) traverse(root);
		return root;
	}
	
	void traverse(TreeNode* root){
		if(root!=nullptr){
			//前序位置
			TreeNode* tmp = root->left;
			root->left = root->right;
			root->right = tmp;
			
			traverse(root->left);
			traverse(root->right);
		}
	}
}
```

这里也可以把前序位置的代码移动到后序位置，但中序是不行的。

## 2. 能不能用分解问题的思维模式解题？

我们给递归函数 `invertTree` 的函数赋予一个定义：

```cpp
// 定义：将以root为根的这棵二叉树翻转，返回翻转以后的二叉树的根节点
TreeNode* invertTree(TreeNode* root);
```

我们来思考，对于一个二叉树节点 x 执行 `invertTree (x)`，能利用这个递归函数的定义做什么呢？

我们可以用 `invertTree(x.left)` 先把 `x` 的左子树翻转，然后用 `invertTree(x.right)` 把 x 的右子树翻转，最后把 x 的左右子树交换，就可以得到以 x 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

我们可以写出如下代码：

```cpp
class Solution{
public:
	// 定义：将以root为根的这棵二叉树翻转，返回翻转以后的二叉树的根节点
	TreeNode* travertTree(TreeNode* root){
		if(root==nullptr){
			return nullptr;
		}
		
		// 利用函数定义，先翻转左右子树
		TreeNode* left = traverTree(root->left);
		TreeNode* right = traverTree(root->right);
		
		//然后交换左右节点
		root->left = right;
		root->right = left;
		
		return root;
	}
}
```

这种分解问题的思路，核心在于要给递归函数一个合适的定义，然后用函数的定义来解释代码。如果逻辑自洽，那么说明算法正确。

# [填充每个二叉树节点的右侧指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

> [!question]
> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
> 
> struct Node {
> 	  int val;
> 	  Node \*left;
> 	  Node \*right;
> 	  Node \*next;
> }
> 
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。
> 
> 初始状态下，所有 next 指针都被设置为 `NULL`。
> 
> **示例 1：**
> 
> ![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)
> 
> **输入：** root = [1,2,3,4,5,6,7]
> **输出：** [1,#,2,3,#,4,5,6,7,#]
> **解释：** 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
> 
> **示例 2:**
> 
> **输入：** root = []
> **输出：** []
> 
> **提示：**
> 
> - 树中节点的数量在 `[0, 212 - 1]` 范围内
> - `-1000 <= node.val <= 1000`
> 
> **进阶：**
> 
> - 你只能使用常量级额外空间。
> - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

这个题目我们以层为单位添加指针，所以很容易想到用层序遍历。利用[[day12 基础二叉树#写法二|层序遍历的写法二]]可以很容易得出答案：

```cpp
class Solution{
	Node *connect(Node *root) {
		  if (root == nullptr)
		    return root;
		  queue<Node *> q;
		  q.push(root);
		  while (!q.empty()) {
		    Node *pre = nullptr;
		    int sz = q.size();
		    for (int i = 0; i < sz; i++) {
		      Node *cur = q.front();
		      q.pop();
		      if (pre != nullptr) {
		        pre->next = cur;
		      }
		      pre = cur;
		      if (cur->left)
		        q.push(cur->left);
		      if (cur->right)
		        q.push(cur->right);
		    }
		  }
		  return root;
	}
}
```

但是根据我们的解题纲领，想想能不能用分解问题的思维模式来解题呢？

似乎不太行哈、、、

但问题还没有结束，进阶中要求使用常量级的空间：

```cpp
class Solution {
public:
  Node *connect(Node *root) {
    if (!root)
      return nullptr;

    // leftmost 记录每一层的开头
    Node *leftmost = root;

    // 只要还有下一层（因为是完美二叉树，有左必有右）
    while (leftmost->left) {
      // cur 负责横向遍历当前已经连好 next 的这一层
      Node *cur = leftmost;

      while (cur) {
        // 情况 1：连接同一个父节点的两个孩子
        cur->left->next = cur->right;

        // 情况 2：跨父节点连接
        // 如果当前节点有 next 邻居，把自己的右孩子连到邻居的左孩子上
        if (cur->next) {
          cur->right->next = cur->next->left;
        }

        // 在当前层继续向右走
        cur = cur->next;
      }

      // 当前层处理完，降到下一层开头
      leftmost = leftmost->left;
    }

    return root;
  }
};

```

# [将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

> [!question]
> 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：
> 
> - 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
> - 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同。
> 
> **示例 1：**
> 
> ![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)
> 
> **输入：** root = [1,2,5,3,4,null,6]
> **输出：** [1,null,2,null,3,null,4,null,5,null,6]
> 
> **示例 2：**
> 
> **输入：** root = []
> **输出：** []
> 
> **示例 3：**
> 
> **输入：** root = [0]
> **输出：** [0]
> 
> **提示：**
> 
> - 树中结点数在范围 `[0, 2000]` 内
> - `-100 <= Node.val <= 100`
> 
> **进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

```cpp
// 函数签名如下
void flatten(TreeNode* root);
```

## 1. 能不能用“遍历”的思维模式来解题？

简单的想：我一边遍历一边构造一条链表不就可以了吗：

```cpp
// 虚拟头节点，dummy.right 就是结果
TreeNode* dummy = new TreeNode(-1);
// 用来构建链表的指针
TreeNode* p = dummy;

void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    p->right = new TreeNode(root->val);
    p = p->right;

    traverse(root->left);
    traverse(root->right);
}
```

但实际上 flatten 函数的返回值是 void, 也就是说题目希望我们在原地可以把二叉树拉成链表，这样一来就没有办法简单的通过遍历解答了。

## 2. 能不能用分解问题的思维模式解题？

我们先尝试给出一个合适的定义：

```cpp
// 定义：输入节点root,然后root为根的二叉树就会被拉平为一条链表
void flatten(TreeNode* root);
```

有这个定义，我们很自然的想到：可以先把左右子树分别拉成链表，然后根据题目要求的先序遍历，可以将左子树拉伸成的链表接到根节点上，然后把右子树拉伸成的链表接到左子树的最后一个节点上，即可得到题目要求的完整的链表。

我们可以写出如下代码：

```cpp
class Solution{
	void flatten(TreeNode* root){
		if(root==nullptr)return;
		
		flatten(root->left);
		flatten(root->right);
		
		TreeNode* left = root->left;
		TreeNode* right = root->right;
		
		root->left = nullptr;
		root->right = left;
		
		TreeNode* p = root;
		while(p->right!=nullptr){
			p=p->right;
		}
		p->right = right;
	}
}
```

这就是递归的魅力呀。