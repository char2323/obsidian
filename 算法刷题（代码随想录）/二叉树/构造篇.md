> [!note]
> 二叉树的构造问题一般都是使用“分解问题”的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树

# [最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

> [!question]
> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
> 
> 1. 创建一个根节点，其值为 `nums` 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
> 
> 返回 _`nums` 构建的_ **_最大二叉树_** 。
> 
> **示例 1：**
> 
> ![](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)
> 
> **输入：** nums = [3,2,1,6,0,5]
> **输出：** [6,3,5,null,2,0,null,null,1]
> **解释：** 递归调用如下所示：
> - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
>     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
>         - 空数组，无子节点。
>         - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
>             - 空数组，无子节点。
>             - 只有一个元素，所以子节点是一个值为 1 的节点。
>     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
>         - 只有一个元素，所以子节点是一个值为 0 的节点。
>         - 空数组，无子节点。
> 
> **示例 2：**
> 
> ![](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)
> 
> **输入：** nums = [3,2,1]
> **输出：** [3,null,2,null,1]
> 
> **提示：**
> 
> - `1 <= nums.length <= 1000`
> - `0 <= nums[i] <= 1000`
> - `nums` 中的所有整数 **互不相同**

```cpp
// 函数签名如下
TreeNode* constructMaximumBinaryTree(vector<int>& nums);
```

每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。

所以，我们要遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树。

可以写出如下代码：

```cpp
class Solution{
public:
	TreeNode* constructMaximumBinaryTree(vector<int>& nums){
		return build(nums,0,nums.size()-1);
	}
	
private:
	// 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点
	TreeNode* build(vector<int>& nums,int lo,int hi){
		if(lo>hi) return nullptr;
		 // 找到数组中的最大值和对应的索引
		 int index = -1,maxVal = INT_MAX;
		 for(int i=lo;i<=hi;i++){
		 	if(maxVal<nums[i]){
		 		maxVal = nums[i];
		 		index = i;
		 	}
		 }
		 // 先构造出根节点
		 TreeNode* root = new TreeNode(maxVal);
		 // 递归调用构造左右子树
		 root->left = build(nums,lo,index-1);
		 root->right = build(nums,index+1,hi);
		
		return root;
	}
}
```

# [从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> [!question]
> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
> 
> **示例 1:**
> 
> ![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)
> 
> **输入:** preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> **输出:** [3,9,20,null,null,15,7]
> 
> **示例 2:**
> 
> **输入:** preorder = [-1], inorder = [-1]
> **输出:** [-1]
> 
> **提示:**
> 
> - `1 <= preorder.length <= 3000`
> - `inorder.length == preorder.length`
> - `-3000 <= preorder[i], inorder[i] <= 3000`
> - `preorder` 和 `inorder` 均 **无重复** 元素
> - `inorder` 均出现在 `preorder`
> - `preorder` **保证** 为二叉树的前序遍历序列
> - `inorder` **保证** 为二叉树的中序遍历序列

```cpp
// 函数签名如下
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder);
```

> 类似上一题，我们肯定要想办法确定根节点的值，把根节点做出来，然后递
> 归构造左右子树即可。

![[Pasted image 20260213235848.png]]

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。

关键在于如何通过根节点的值，将 `preorder` 和 `inorder` 数组划分成两半，构造根节点的左右子树？

换句话说，对于以下代码中的 `?` 部分应该填入什么：

```cpp
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    // 根据函数定义，用 preorder 和 inorder 构造二叉树
    return build(preorder, 0, preorder.size() - 1,
                inorder, 0, inorder.size() - 1);
}

// build 函数的定义：
// 若前序遍历数组为 preorder[preStart..preEnd]，
// 中序遍历数组为 inorder[inStart..inEnd]，
// 构造二叉树，返回该二叉树的根节点
TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                vector<int>& inorder, int inStart, int inEnd) {
    if (preStart > preEnd) {
        return NULL;
    }
    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    int index;
    for (int i = inStart; i<= inEnd; i++) {
        // rootVal 在中序遍历数组中的索引
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    TreeNode* root = new TreeNode(rootVal);
    int leftSize = index - inStart;
    // 递归构造左右子树
    root->left = build(preorder, ?, ?,
                    inorder, ?, ?);

    root->right = build(preorder, ?, ?,
                    inorder, ?, ?);
    return root;
}
```

代码中的一些变量如图所示：

![[Pasted image 20260214000420.png]]

此外用 for 循环查找 index 效率不高，可以用哈希表来优化：因为题目说二叉树节点的值不存在重复，所以可以使用一个 HashMap 存储元素到索引的映射，这样就可以直接通过 HashMap 查到 `rootVal` 对应的 `index`：

```cpp
// 存储 inorder 中值到索引的映射
unordered_map<int, int> valToIndex;

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    for (int i = 0; i < inorder.size(); i++) {
        valToIndex[inorder[i]] = i;
    }
    return build(preorder, 0, preorder.size() - 1,
                 inorder, 0, inorder.size() - 1);
}

TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                vector<int>& inorder, int inStart, int inEnd) {
    int rootVal = preorder[preStart];
    // 避免 for 循环寻找 rootVal
    int index = valToIndex[rootVal];
    // ...
}
```

现在最核心的问题还是这几个问号该填什么呢：

```cpp
root.left = build(preorder, ?, ?,
                  inorder, ?, ?);

root.right = build(preorder, ?, ?,
                   inorder, ?, ?);
```

对于左右子树对应的 `inorder` 数组的起始索引和终止索引比较容易确定：

```cpp
root.left = build(preorder, ?, ?,
                  inorder, inStart, index - 1);

root.right = build(preorder, ?, ?,
                   inorder, index + 1, inEnd);
```

对于 `preorder` 数组呢？如何确定左右数组对应的起始索引和终止索引？

这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

![[Pasted image 20260214001121.png]]

看着这个图就可以把 `preorder` 对应的索引写进去了：

```cpp
int leftSize = index - inStart;

root.left = build(preorder, preStart + 1, preStart + leftSize,
                  inorder, inStart, index - 1);

root.right = build(preorder, preStart + leftSize + 1, preEnd,
                   inorder, index + 1, inEnd);
```

所以根据上面的分析，我们可以写出如下代码：

```cpp
class Solution {
public:
    // 存储 inorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                    inorder, 0, inorder.size() - 1);
    }

    // build 函数的定义：
    // 若前序遍历数组为 preorder[preStart..preEnd]，
    // 中序遍历数组为 inorder[inStart..inEnd]，
    // 构造二叉树，返回该二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd) {

        if (preStart > preEnd) {
            return NULL;
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // rootVal 在中序遍历数组中的索引
        int index = valToIndex[rootVal];

        int leftSize = index - inStart;

        // 先构造出当前根节点
        TreeNode* root = new TreeNode(rootVal); /**<extend up -200>![](/images/algo/binary-tree-ii/4.jpeg) */
        // 递归构造左右子树
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                        inorder, inStart, index - 1);

        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                        inorder, index + 1, inEnd);
        return root;
    }
};
```

# [从后序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> [!question]
> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。
> 
> **示例 1:**
> 
> ![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)
> 
> **输入：** inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> **输出：** [3,9,20,null,null,15,7]
> 
> **示例 2:**
> 
> **输入：** inorder = [-1], postorder = [-1]
> **输出：** [-1]
> 
> **提示:**
> 
> - `1 <= inorder.length <= 3000`
> - `postorder.length == inorder.length`
> - `-3000 <= inorder[i], postorder[i] <= 3000`
> - `inorder` 和 `postorder` 都由 **不同** 的值组成
> - `postorder` 中每一个值都在 `inorder` 中
> - `inorder` **保证**是树的中序遍历
> - `postorder` **保证**是树的后序遍历

```cpp
// 函数签名如下
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder);
```

![[Pasted image 20260214001850.png]]

```cpp
int leftSize = index - inStart;

root.left = build(inorder, inStart, index - 1,
                  postorder, postStart, postStart + leftSize - 1);

root.right = build(inorder, index + 1, inEnd,
                   postorder, postStart + leftSize, postEnd - 1);
```

这里要注意的是，对于后序遍历的 `left` 边界，是 `postStart + leftSize - 1`，其余和上一题几乎一样。

```cpp
class Solution {
    // 存储 inorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++) {
            valToIndex[inorder[i]] = i;
        }
        return build(inorder, 0, inorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    // 定义：中序遍历数组为 inorder[inStart..inEnd]，
    // 后序遍历数组为 postorder[postStart..postEnd]，
    // build 函数构造这个二叉树并返回该二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd,
                    vector<int>& postorder, int postStart, int postEnd) {

        if (inStart > inEnd) {
            return nullptr;
        }
        // root 节点对应的值就是后序遍历数组的最后一个元素
        int rootVal = postorder[postEnd];
        // rootVal 在中序遍历数组中的索引
        int index = valToIndex[rootVal];
        // 左子树的节点个数
        int leftSize = index - inStart;
        TreeNode* root = new TreeNode(rootVal);

        // 递归构造左右子树
        root->left = build(inorder, inStart, index - 1,
                           postorder, postStart, postStart + leftSize - 1);
        
        root->right = build(inorder, index + 1, inEnd,
                            postorder, postStart + leftSize, postEnd - 1);
        return root;
    }
};
```

# [根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

> [!question]
> 给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。
> 
> 如果存在多个答案，您可以返回其中 **任何** 一个。
> 
> **示例 1：**
> 
> ![](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)
> 
> **输入：** preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
> **输出：** [1,2,3,4,5,6,7]
> 
> **示例 2:**
> 
> **输入:** preorder = [1], postorder = [1]
> **输出:** [1]
> 
> **提示：**
> 
> - `1 <= preorder.length <= 30`
> - `1 <= preorder[i] <= preorder.length`
> - `preorder` 中所有值都 **不同**
> - `postorder.length == preorder.length`
> - `1 <= postorder[i] <= postorder.length`
> - `postorder` 中所有值都 **不同**
> - 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历

```cpp
TreeNode* constructFromPrePost(vector<int>& preOrder, vector<int>& postOrder);
```

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树**。

题目也说了，如果有多种可能的还原结果，你可以返回任意一种。

为什么呢？我们说过，构建二叉树的套路很简单，先找到根节点，然后找到并递归构造左右子树即可。

前两道题，可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树（题目说了树中没有 `val` 相同的节点）。

这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点。

不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：

1. **首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值**。
2. **然后把前序遍历结果的第二个元素作为左子树的根节点的值**
3. **在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可**

![[Pasted image 20260214002650.png]]

可写出如下代码：

```cpp
class Solution {
    // 存储 postorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        for (int i = 0; i < postorder.size(); i++) {
            valToIndex[postorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                    postorder, 0, postorder.size() - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                   vector<int>& postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex[leftRootVal];
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode* root = new TreeNode(rootVal); /**<extend up -200>![](/images/algo/binary-tree-ii/8.jpeg) */
        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
};
```
