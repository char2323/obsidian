主要数据结构为：数组、动态数组、链表、队列、栈、哈希表、树、图、堆、并查集、前缀树

### 1. 数组 (Array) & 动态数组 (Dynamic Array)

这是最基础的结构，也是算法题的半壁江山。

- **核心特性**：
    
    - 连续内存空间，随机访问 $O(1)$。
        
    - 插入/删除平均 $O(N)$（因为需要移动元素）。
        
    - **动态数组**（如 C++ `std::vector`, Java `ArrayList`）：自动扩容（通常是 1.5 倍或 2 倍），摊还复杂度为 $O(1)$。
        
- **必刷算法/技巧**：
    
    - **双指针 (Two Pointers)**：
        
        - **快慢指针**：用于原地移除元素、去重。
            
        - **左右指针**：二分查找、反转数组、两数之和（有序数组）。
            
    - **滑动窗口 (Sliding Window)**：处理子数组（Subarray）问题，如“最小覆盖子串”、“最大连续 1 的个数”。
        
    - **前缀和 (Prefix Sum)**：快速计算区间和 $O(1)$。
        
    - **差分数组 (Difference Array)**：频繁对区间进行加减操作。
        

### 2. 链表 (Linked List)

链表考察的是对指针（引用）的精准控制，容错率低。

- **核心特性**：
    
    - 节点非连续存储，通过指针连接。
        
    - 插入/删除 $O(1)$（已知位置），查询 $O(N)$。
        
- **必刷算法/技巧**：
    
    - **反转链表**：迭代法（双指针）和递归法。这是最基础的“手撕”题。
        
    - **快慢指针 (Floyd's Cycle Finding)**：
        
        - 检测是否有环。
            
        - 寻找链表中点（归并排序链表时用到）。
            
        - 寻找倒数第 $k$ 个节点。
            
    - **虚拟头结点 (Dummy Head)**：处理头结点可能被删除的情况，简化代码逻辑。
        
    - **合并两个/K个有序链表**。
        

### 3. 栈 (Stack) & 队列 (Queue)

通常作为辅助结构出现在复杂算法中。

- **核心特性**：
    
    - 栈：LIFO（后进先出）。
        
    - 队列：FIFO（先进先出）。
        
- **必刷算法/技巧**：
    
    - **单调栈 (Monotonic Stack)**：解决“下一个更大元素 (Next Greater Element)”、“接雨水”、“柱状图中最大的矩形”等问题。
        
    - **括号匹配**：栈的经典应用。
        
    - **BFS 的实现**：队列是广度优先搜索的核心容器。
        
    - **单调队列 (Monotonic Queue)**：滑动窗口最大值问题。
        

### 4. 哈希表 (Hash Table)

“空间换时间”的代表，解决查找、计数问题。

- **核心特性**：
    
    - 键值对存储，理想情况增删改查均为 $O(1)$。
        
    - **碰撞处理**：拉链法（Chaining）和 开放寻址法（Open Addressing）。
        
- **必刷算法/技巧**：
    
    - **两数之和 (Two Sum)**：哈希表的入门题。
        
    - **异位词分组**：字符串排序后作为 Key，或计数作为 Key。
        
    - **原地哈希**：利用数组下标作为哈希 Key（如“缺失的第一个正数”）。
        
    - **LRU 缓存机制**：哈希表 + 双向链表的结合。
        

### 5. 树 (Tree) & 二叉搜索树 (BST)

递归思维的训练场。

- **核心特性**：
    
    - **BST**：左子树所有节点 < 根 < 右子树所有节点。中序遍历是有序的。
        
- **必刷算法/技巧**：
    
    - **DFS (深度优先搜索)**：
        
        - 前序、中序、后序遍历（递归与迭代写法都要掌握）。
            
        - 计算树的高度、直径、路径和。
            
    - **BFS (广度优先搜索)**：层序遍历，通常结合队列使用。
        
    - **LCA (最近公共祖先)**：普通二叉树和 BST 的不同解法。
        
    - **树的序列化与反序列化**。
        

### 6. 堆 (Heap) / 优先队列 (Priority Queue) 

这是你列表中未提及但极重要的结构。

- **核心特性**：
    
    - **完全二叉树**。大顶堆（根最大）或小顶堆（根最小）。
        
    - 插入 $O(\log N)$，删除堆顶 $O(\log N)$，获取堆顶 $O(1)$。
        
- **必刷算法/技巧**：
    
    - **Top K 问题**：数组中第 K 大的元素（维护一个大小为 K 的小顶堆）。
        
    - **数据流的中位数**：双堆法（一个大顶堆+一个小顶堆）。
        
    - **合并 K 个有序链表**。
        

### 7. 图 (Graph)

最复杂的数据结构，考察逻辑和建模能力。

- **核心存储**：邻接矩阵（Adjacency Matrix） vs 邻接表（Adjacency List）。
    
- **必刷算法/技巧**：
    
    - **图的遍历**：DFS（找路径、连通性）和 BFS（无权图最短路径）。
        
    - **拓扑排序 (Topological Sort)**：解决依赖关系问题（如课程表），使用入度表（Kahn算法）或 DFS。
        
    - **二分图判定**：染色法。
        
    - **最短路径**：
        
        - **Dijkstra**：非负权图最短路径（配合优先队列优化）。
            
        - **Floyd**：多源最短路径（动态规划思想）。
            
    - **最小生成树 (MST)**：Prim 和 Kruskal 算法（了解即可，笔试偶尔考）。
        

### 8. 其他重要的补充结构

- **前缀树 (Trie / Prefix Tree)**：
    
    - 专门处理字符串匹配、前缀查询。
        
    - 应用：自动补全、拼写检查。
        
    - 算法：插入字符串、搜索前缀。
        
- **并查集 (Union-Find / Disjoint Set)**：
    
    - 处理不相交集合的合并及查询问题。
        
    - 核心操作：`find` (查找根节点+路径压缩), `union` (按秩合并)。
        
    - 应用：岛屿数量、朋友圈个数、判断图中是否有环（无向图）。
        
- **位运算 (Bit Manipulation)**：
    
    - 虽然不是数据结构，但常与数组/哈希结合。
        
    - 技巧：`n & (n-1)` 消除最后一个 1，异或 `^` 性质（相同为0，不同为1）。
        

---

### 总结与复习建议表

|**数据结构**|**核心操作复杂度**|**杀手锏算法 (必须掌握)**|
|---|---|---|
|**数组**|访问 $O(1)$|双指针、滑动窗口、前缀和|
|**链表**|插入/删除 $O(1)$|翻转、快慢指针、环检测|
|**栈/队列**|操作 $O(1)$|单调栈、BFS|
|**哈希表**|查找 $O(1)$|Two Sum、计数、去重|
|**堆**|调整 $O(\log N)$|Top K、流中位数|
|**树**|搜索 $O(\log N)$(BST)|递归(DFS)、层序(BFS)、LCA|
|**图**|-|Dijkstra、拓扑排序、并查集|
建议的下一步￼￼：

你想从哪个具体的数据结构开始深入复习？或者需要我为你出一道该类别的经典“热身题”来找找手感？